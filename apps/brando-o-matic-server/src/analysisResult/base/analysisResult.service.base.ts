/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { PrismaService } from "../../prisma/prisma.service";
import { Prisma, AnalysisResult as PrismaAnalysisResult } from "@prisma/client";
import { AnalysisResultOutput } from "../AnalysisResultOutput";

export class AnalysisResultServiceBase {
  constructor(protected readonly prisma: PrismaService) {}

  async count(
    args: Omit<Prisma.AnalysisResultCountArgs, "select">
  ): Promise<number> {
    return this.prisma.analysisResult.count(args);
  }

  async analysisResults<T extends Prisma.AnalysisResultFindManyArgs>(
    args: Prisma.SelectSubset<T, Prisma.AnalysisResultFindManyArgs>
  ): Promise<PrismaAnalysisResult[]> {
    return this.prisma.analysisResult.findMany<Prisma.AnalysisResultFindManyArgs>(
      args
    );
  }
  async analysisResult<T extends Prisma.AnalysisResultFindUniqueArgs>(
    args: Prisma.SelectSubset<T, Prisma.AnalysisResultFindUniqueArgs>
  ): Promise<PrismaAnalysisResult | null> {
    return this.prisma.analysisResult.findUnique(args);
  }
  async createAnalysisResult<T extends Prisma.AnalysisResultCreateArgs>(
    args: Prisma.SelectSubset<T, Prisma.AnalysisResultCreateArgs>
  ): Promise<PrismaAnalysisResult> {
    return this.prisma.analysisResult.create<T>(args);
  }
  async updateAnalysisResult<T extends Prisma.AnalysisResultUpdateArgs>(
    args: Prisma.SelectSubset<T, Prisma.AnalysisResultUpdateArgs>
  ): Promise<PrismaAnalysisResult> {
    return this.prisma.analysisResult.update<T>(args);
  }
  async deleteAnalysisResult<T extends Prisma.AnalysisResultDeleteArgs>(
    args: Prisma.SelectSubset<T, Prisma.AnalysisResultDeleteArgs>
  ): Promise<PrismaAnalysisResult> {
    return this.prisma.analysisResult.delete(args);
  }
  async FetchAnalysisResult(args: string): Promise<AnalysisResultOutput> {
    throw new Error("Not implemented");
  }
  async GetAnalysisResult(args: string): Promise<string> {
    throw new Error("Not implemented");
  }
}
